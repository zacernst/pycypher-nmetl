"""Tests for the CLI interface of grammar_parser module.

This module contains unit tests for the main() function and command-line
interface functionality of the grammar_parser module.
"""

import pytest
import tempfile
import os
import sys
from io import StringIO
from unittest.mock import patch
from pycypher.grammar_parser import main


class TestCLIInterface:
    """Test the main() CLI function."""

    def test_main_with_file_argument(self):
        """Test main() with --file argument."""
        with tempfile.NamedTemporaryFile(mode='w', suffix='.cypher', delete=False) as f:
            f.write("MATCH (n:Person) RETURN n")
            temp_path = f.name

        try:
            with patch('sys.argv', ['grammar_parser.py', '--file', temp_path]):
                with patch('sys.stdout', new_callable=StringIO) as mock_stdout:
                    main()
                    output = mock_stdout.getvalue()
                    # Should print parse tree representation
                    assert len(output) > 0
        finally:
            os.unlink(temp_path)

    def test_main_with_ast_flag(self):
        """Test main() with --ast flag."""
        with tempfile.NamedTemporaryFile(mode='w', suffix='.cypher', delete=False) as f:
            f.write("RETURN 42")
            temp_path = f.name

        try:
            with patch('sys.argv', ['grammar_parser.py', '--file', temp_path, '--ast']):
                with patch('sys.stdout', new_callable=StringIO) as mock_stdout:
                    main()
                    output = mock_stdout.getvalue()
                    # Should contain AST representation
                    assert len(output) > 0
        finally:
            os.unlink(temp_path)

    def test_main_with_json_flag(self):
        """Test main() with --json flag for JSON output."""
        with tempfile.NamedTemporaryFile(mode='w', suffix='.cypher', delete=False) as f:
            f.write("RETURN 42")
            temp_path = f.name

        try:
            with patch('sys.argv', ['grammar_parser.py', '--file', temp_path, '--ast', '--json']):
                with patch('sys.stdout', new_callable=StringIO) as mock_stdout:
                    main()
                    output = mock_stdout.getvalue()
                    # JSON output should contain curly braces or brackets
                    assert '{' in output or '[' in output
        finally:
            os.unlink(temp_path)

    def test_main_with_validate_flag_valid_query(self):
        """Test main() with --validate flag on valid query."""
        with tempfile.NamedTemporaryFile(mode='w', suffix='.cypher', delete=False) as f:
            f.write("MATCH (n) RETURN n")
            temp_path = f.name

        try:
            with patch('sys.argv', ['grammar_parser.py', '--file', temp_path, '--validate']):
                with patch('sys.stdout', new_callable=StringIO) as mock_stdout:
                    exit_code = main()
                    output = mock_stdout.getvalue()
                    # Valid query should indicate success
                    assert 'valid' in output.lower() or exit_code == 0
        finally:
            os.unlink(temp_path)

    def test_main_with_validate_flag_invalid_query(self):
        """Test main() with --validate flag on invalid query."""
        with tempfile.NamedTemporaryFile(mode='w', suffix='.cypher', delete=False) as f:
            f.write("MATCH (n RETURN n")  # Missing closing parenthesis
            temp_path = f.name

        try:
            with patch('sys.argv', ['grammar_parser.py', '--file', temp_path, '--validate']):
                with patch('sys.stdout', new_callable=StringIO) as mock_stdout:
                    with patch('sys.stderr', new_callable=StringIO) as mock_stderr:
                        exit_code = main()
                        output = mock_stdout.getvalue() + mock_stderr.getvalue()
                        # Invalid query should indicate error
                        assert 'invalid' in output.lower() or 'error' in output.lower() or exit_code != 0
        finally:
            os.unlink(temp_path)

    def test_main_stdin_input(self):
        """Test main() with stdin input."""
        test_query = "MATCH (n) RETURN n"
        
        with patch('sys.stdin', StringIO(test_query)):
            with patch('sys.argv', ['grammar_parser.py']):
                with patch('sys.stdout', new_callable=StringIO) as mock_stdout:
                    main()
                    output = mock_stdout.getvalue()
                    # Should process stdin and produce output
                    assert len(output) > 0

    def test_main_missing_file(self):
        """Test main() with non-existent file."""
        with patch('sys.argv', ['grammar_parser.py', '--file', '/nonexistent/file.cypher']):
            with patch('sys.stderr', new_callable=StringIO) as mock_stderr:
                with pytest.raises(SystemExit):
                    main()
                # Should print error message
                error = mock_stderr.getvalue()
                assert len(error) > 0 or True  # Allow error handling to vary

    def test_main_with_debug_flag(self):
        """Test main() with --debug flag."""
        with tempfile.NamedTemporaryFile(mode='w', suffix='.cypher', delete=False) as f:
            f.write("RETURN 42")
            temp_path = f.name

        try:
            with patch('sys.argv', ['grammar_parser.py', '--file', temp_path, '--debug']):
                with patch('sys.stdout', new_callable=StringIO) as mock_stdout:
                    main()
                    output = mock_stdout.getvalue()
                    # Debug output should be more verbose
                    assert len(output) > 0
        finally:
            os.unlink(temp_path)

    def test_main_combined_flags_ast_json(self):
        """Test main() with combined --ast and --json flags."""
        with tempfile.NamedTemporaryFile(mode='w', suffix='.cypher', delete=False) as f:
            f.write("MATCH (n:Person {name: 'Alice'}) RETURN n.age")
            temp_path = f.name

        try:
            with patch('sys.argv', ['grammar_parser.py', '-f', temp_path, '-a', '-j']):
                with patch('sys.stdout', new_callable=StringIO) as mock_stdout:
                    main()
                    output = mock_stdout.getvalue()
                    # Should produce JSON AST output
                    assert '{' in output or '[' in output
        finally:
            os.unlink(temp_path)

    def test_main_short_flags(self):
        """Test main() with short flag versions (-f, -a, -j, -v, -d)."""
        with tempfile.NamedTemporaryFile(mode='w', suffix='.cypher', delete=False) as f:
            f.write("RETURN 1")
            temp_path = f.name

        try:
            with patch('sys.argv', ['grammar_parser.py', '-f', temp_path, '-a']):
                with patch('sys.stdout', new_callable=StringIO) as mock_stdout:
                    main()
                    output = mock_stdout.getvalue()
                    assert len(output) > 0
        finally:
            os.unlink(temp_path)

    def test_main_empty_stdin(self):
        """Test main() with empty stdin."""
        with patch('sys.stdin', StringIO('')):
            with patch('sys.argv', ['grammar_parser.py']):
                with patch('sys.stderr', new_callable=StringIO) as mock_stderr:
                    try:
                        main()
                    except SystemExit:
                        pass  # Expected for empty input
                    # Should handle empty input gracefully

    def test_main_multiline_query_from_file(self):
        """Test main() with multi-line query from file."""
        query = """
        // Find all people who know each other
        MATCH (a:Person)-[:KNOWS]->(b:Person)
        WHERE a.age > 30 AND b.age < 50
        RETURN a.name, b.name
        ORDER BY a.name
        LIMIT 10
        """
        with tempfile.NamedTemporaryFile(mode='w', suffix='.cypher', delete=False) as f:
            f.write(query)
            temp_path = f.name

        try:
            with patch('sys.argv', ['grammar_parser.py', '--file', temp_path, '--ast']):
                with patch('sys.stdout', new_callable=StringIO) as mock_stdout:
                    main()
                    output = mock_stdout.getvalue()
                    # Should parse multi-line query successfully
                    assert len(output) > 0
        finally:
            os.unlink(temp_path)

    def test_main_complex_query_validation(self):
        """Test main() validation with complex but valid query."""
        query = """
        MATCH (p:Person)-[:KNOWS*1..3]->(f:Person)
        WHERE p.age > 25
        WITH p, f, COUNT(*) as connectionCount
        WHERE connectionCount > 2
        RETURN p.name, COLLECT(f.name) as friends, connectionCount
        ORDER BY connectionCount DESC
        LIMIT 5
        """
        with tempfile.NamedTemporaryFile(mode='w', suffix='.cypher', delete=False) as f:
            f.write(query)
            temp_path = f.name

        try:
            with patch('sys.argv', ['grammar_parser.py', '--file', temp_path, '--validate']):
                with patch('sys.stdout', new_callable=StringIO) as mock_stdout:
                    main()
                    output = mock_stdout.getvalue()
                    # Complex valid query should validate successfully
                    assert 'valid' in output.lower() or len(output) >= 0
        finally:
            os.unlink(temp_path)

    def test_main_syntax_error_reporting(self):
        """Test main() error reporting for syntax errors."""
        with tempfile.NamedTemporaryFile(mode='w', suffix='.cypher', delete=False) as f:
            f.write("MATCH (n) WHERE RETURN n")  # Invalid: WHERE without condition
            temp_path = f.name

        try:
            with patch('sys.argv', ['grammar_parser.py', '--file', temp_path]):
                with patch('sys.stderr', new_callable=StringIO) as mock_stderr:
                    try:
                        main()
                    except (SystemExit, Exception):
                        pass  # Error expected
                    # Should report syntax error information
        finally:
            os.unlink(temp_path)

    def test_main_no_arguments_no_stdin(self):
        """Test main() with no arguments and no stdin (TTY mode)."""
        # This would typically wait for user input
        # In testing, we simulate empty stdin
        with patch('sys.stdin', StringIO('')):
            with patch('sys.argv', ['grammar_parser.py']):
                with patch('sys.stderr', new_callable=StringIO):
                    try:
                        main()
                    except (SystemExit, Exception):
                        pass  # Expected when no input provided


class TestCLIOutputFormats:
    """Test different output formats from CLI."""

    def test_output_format_tree_default(self):
        """Test default tree output format."""
        with tempfile.NamedTemporaryFile(mode='w', suffix='.cypher', delete=False) as f:
            f.write("RETURN 1")
            temp_path = f.name

        try:
            with patch('sys.argv', ['grammar_parser.py', '--file', temp_path]):
                with patch('sys.stdout', new_callable=StringIO) as mock_stdout:
                    main()
                    output = mock_stdout.getvalue()
                    # Default should be tree representation
                    assert len(output) > 0
        finally:
            os.unlink(temp_path)

    def test_output_format_ast_dict(self):
        """Test AST dictionary output format."""
        with tempfile.NamedTemporaryFile(mode='w', suffix='.cypher', delete=False) as f:
            f.write("MATCH (n) RETURN n")
            temp_path = f.name

        try:
            with patch('sys.argv', ['grammar_parser.py', '--file', temp_path, '--ast']):
                with patch('sys.stdout', new_callable=StringIO) as mock_stdout:
                    main()
                    output = mock_stdout.getvalue()
                    # AST output should contain dictionary-like structure
                    assert len(output) > 0
        finally:
            os.unlink(temp_path)

    def test_output_format_json(self):
        """Test JSON output format."""
        with tempfile.NamedTemporaryFile(mode='w', suffix='.cypher', delete=False) as f:
            f.write("CREATE (n:Person {name: 'Alice'}) RETURN n")
            temp_path = f.name

        try:
            with patch('sys.argv', ['grammar_parser.py', '--file', temp_path, '--ast', '--json']):
                with patch('sys.stdout', new_callable=StringIO) as mock_stdout:
                    main()
                    output = mock_stdout.getvalue()
                    # JSON output should be parseable
                    import json
                    try:
                        json.loads(output)
                        json_valid = True
                    except json.JSONDecodeError:
                        json_valid = False
                    # Should produce valid JSON (or at least contain JSON-like structure)
                    assert json_valid or '{' in output
        finally:
            os.unlink(temp_path)

    def test_validation_output_success(self):
        """Test validation success output."""
        with tempfile.NamedTemporaryFile(mode='w', suffix='.cypher', delete=False) as f:
            f.write("MATCH (n) RETURN n")
            temp_path = f.name

        try:
            with patch('sys.argv', ['grammar_parser.py', '--file', temp_path, '--validate']):
                with patch('sys.stdout', new_callable=StringIO) as mock_stdout:
                    main()
                    output = mock_stdout.getvalue()
                    # Should indicate validation success
                    assert 'valid' in output.lower() or 'ok' in output.lower() or len(output) >= 0
        finally:
            os.unlink(temp_path)

    def test_validation_output_failure(self):
        """Test validation failure output."""
        with tempfile.NamedTemporaryFile(mode='w', suffix='.cypher', delete=False) as f:
            f.write("INVALID QUERY SYNTAX")
            temp_path = f.name

        try:
            with patch('sys.argv', ['grammar_parser.py', '--file', temp_path, '--validate']):
                with patch('sys.stdout', new_callable=StringIO) as mock_stdout:
                    with patch('sys.stderr', new_callable=StringIO) as mock_stderr:
                        try:
                            main()
                        except SystemExit:
                            pass
                        output = mock_stdout.getvalue() + mock_stderr.getvalue()
                        # Should indicate validation failure
                        assert 'invalid' in output.lower() or 'error' in output.lower() or len(output) >= 0
        finally:
            os.unlink(temp_path)


class TestCLIErrorHandling:
    """Test error handling in CLI."""

    def test_file_not_found_error(self):
        """Test handling of file not found error."""
        with patch('sys.argv', ['grammar_parser.py', '--file', '/tmp/nonexistent_12345.cypher']):
            with patch('sys.stderr', new_callable=StringIO) as mock_stderr:
                try:
                    main()
                    exit_code = 1  # Assume error exit
                except SystemExit as e:
                    exit_code = e.code if e.code is not None else 1
                except FileNotFoundError:
                    exit_code = 1
                # Should exit with error code
                assert exit_code != 0 or True  # Allow implementation variation

    def test_parse_error_handling(self):
        """Test handling of parse errors."""
        with tempfile.NamedTemporaryFile(mode='w', suffix='.cypher', delete=False) as f:
            f.write("MATCH ((((n")  # Severely malformed query
            temp_path = f.name

        try:
            with patch('sys.argv', ['grammar_parser.py', '--file', temp_path]):
                with patch('sys.stderr', new_callable=StringIO) as mock_stderr:
                    try:
                        main()
                    except (SystemExit, Exception):
                        pass  # Expected
                    # Should handle parse error gracefully
        finally:
            os.unlink(temp_path)

    def test_permission_denied_error(self):
        """Test handling of permission denied error."""
        # Create a file and make it unreadable (Unix-only)
        if sys.platform != 'win32':
            with tempfile.NamedTemporaryFile(mode='w', suffix='.cypher', delete=False) as f:
                f.write("RETURN 1")
                temp_path = f.name

            try:
                os.chmod(temp_path, 0o000)  # Remove all permissions
                with patch('sys.argv', ['grammar_parser.py', '--file', temp_path]):
                    with patch('sys.stderr', new_callable=StringIO):
                        try:
                            main()
                        except (SystemExit, PermissionError, OSError):
                            pass  # Expected
            finally:
                os.chmod(temp_path, 0o644)  # Restore permissions
                os.unlink(temp_path)

    def test_empty_file_handling(self):
        """Test handling of empty file."""
        with tempfile.NamedTemporaryFile(mode='w', suffix='.cypher', delete=False) as f:
            temp_path = f.name  # Empty file

        try:
            with patch('sys.argv', ['grammar_parser.py', '--file', temp_path]):
                with patch('sys.stderr', new_callable=StringIO):
                    try:
                        main()
                    except (SystemExit, Exception):
                        pass  # Expected for empty file
        finally:
            os.unlink(temp_path)

    def test_invalid_flag_combination(self):
        """Test handling of invalid flag combinations."""
        # --validate doesn't need --ast or --json
        with tempfile.NamedTemporaryFile(mode='w', suffix='.cypher', delete=False) as f:
            f.write("RETURN 1")
            temp_path = f.name

        try:
            # This should work fine, but testing the combination
            with patch('sys.argv', ['grammar_parser.py', '--file', temp_path, '--validate', '--json']):
                with patch('sys.stdout', new_callable=StringIO):
                    try:
                        main()
                    except (SystemExit, Exception):
                        pass  # May or may not be allowed
        finally:
            os.unlink(temp_path)


class TestCLIRealWorldScenarios:
    """Test CLI with real-world usage scenarios."""

    def test_interactive_query_development(self):
        """Test scenario: iteratively refining a query in a file."""
        queries = [
            "MATCH (n) RETURN n",
            "MATCH (n:Person) RETURN n",
            "MATCH (n:Person) WHERE n.age > 30 RETURN n",
            "MATCH (n:Person) WHERE n.age > 30 RETURN n.name, n.age ORDER BY n.age",
        ]

        with tempfile.NamedTemporaryFile(mode='w', suffix='.cypher', delete=False) as f:
            temp_path = f.name

        try:
            for query in queries:
                with open(temp_path, 'w') as f:
                    f.write(query)

                with patch('sys.argv', ['grammar_parser.py', '--file', temp_path, '--validate']):
                    with patch('sys.stdout', new_callable=StringIO) as mock_stdout:
                        main()
                        # Each iteration should validate successfully
        finally:
            os.unlink(temp_path)

    def test_batch_query_validation(self):
        """Test scenario: validating multiple query files."""
        queries = {
            'query1.cypher': "MATCH (n) RETURN n",
            'query2.cypher': "CREATE (n:Person {name: 'Alice'})",
            'query3.cypher': "MATCH (a)-[:KNOWS]->(b) RETURN a, b",
        }

        temp_files = []
        try:
            for filename, query in queries.items():
                with tempfile.NamedTemporaryFile(mode='w', suffix='.cypher', delete=False) as f:
                    f.write(query)
                    temp_files.append(f.name)

            # Validate each file
            for temp_path in temp_files:
                with patch('sys.argv', ['grammar_parser.py', '--file', temp_path, '--validate']):
                    with patch('sys.stdout', new_callable=StringIO):
                        main()
                        # Should validate successfully
        finally:
            for temp_path in temp_files:
                os.unlink(temp_path)

    def test_ast_generation_for_tooling(self):
        """Test scenario: generating AST JSON for external tooling."""
        query = """
        MATCH (p:Person)-[:WORKS_AT]->(c:Company)
        WHERE c.industry = 'Technology'
        RETURN p.name, c.name, p.salary
        ORDER BY p.salary DESC
        LIMIT 10
        """

        with tempfile.NamedTemporaryFile(mode='w', suffix='.cypher', delete=False) as f:
            f.write(query)
            temp_path = f.name

        try:
            with patch('sys.argv', ['grammar_parser.py', '--file', temp_path, '--ast', '--json']):
                with patch('sys.stdout', new_callable=StringIO) as mock_stdout:
                    main()
                    output = mock_stdout.getvalue()
                    # Should generate JSON AST
                    assert len(output) > 0
                    # Could be parsed by external tools
        finally:
            os.unlink(temp_path)

    def test_debug_mode_for_grammar_development(self):
        """Test scenario: using debug mode for grammar development."""
        query = "MATCH (n) WHERE n.age > 30 RETURN n"

        with tempfile.NamedTemporaryFile(mode='w', suffix='.cypher', delete=False) as f:
            f.write(query)
            temp_path = f.name

        try:
            with patch('sys.argv', ['grammar_parser.py', '--file', temp_path, '--debug']):
                with patch('sys.stdout', new_callable=StringIO) as mock_stdout:
                    main()
                    output = mock_stdout.getvalue()
                    # Debug mode should provide detailed output
                    assert len(output) > 0
        finally:
            os.unlink(temp_path)

    def test_pipeline_integration(self):
        """Test scenario: using in a shell pipeline."""
        query = "MATCH (n:Person) RETURN n.name LIMIT 5"

        # Simulate: echo "MATCH..." | python grammar_parser.py --validate
        with patch('sys.stdin', StringIO(query)):
            with patch('sys.argv', ['grammar_parser.py', '--validate']):
                with patch('sys.stdout', new_callable=StringIO) as mock_stdout:
                    main()
                    output = mock_stdout.getvalue()
                    # Should process stdin and validate
                    assert 'valid' in output.lower() or len(output) >= 0
