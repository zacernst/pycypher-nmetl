"""Pydantic models for openCypher AST nodes.

This module provides strongly-typed Pydantic models for the Abstract Syntax Tree
generated by the grammar parser. It includes utilities for converting dict-based
ASTs to typed models, traversing, modifying, and pretty-printing the AST.

Usage:
    from pycypher.grammar_parser import GrammarParser
    from pycypher.ast_models import ASTConverter
    
    parser = GrammarParser()
    raw_ast = parser.parse_to_ast("MATCH (n:Person) RETURN n")
    
    converter = ASTConverter()
    typed_ast = converter.convert(raw_ast)
    
    # Traverse the AST
    for node in typed_ast.traverse():
        print(f"Node type: {node.__class__.__name__}")
    
    # Pretty print
    print(typed_ast.pretty())
"""

from __future__ import annotations
from typing import Any, Optional, Union, List, Dict, Iterator, Callable, cast
from pydantic import BaseModel, Field, ConfigDict
from abc import ABC, abstractmethod


# ============================================================================
# Base Classes
# ============================================================================

class ASTNode(BaseModel, ABC):
    """Base class for all AST nodes."""
    
    model_config = ConfigDict(arbitrary_types_allowed=True)
    
    def traverse(self, depth: int = 0) -> Iterator['ASTNode']:
        """
        Traverse the AST depth-first, yielding all nodes.
        
        Args:
            depth: Current depth in the tree (used internally)
            
        Yields:
            ASTNode: Each node in the tree
        """
        yield self
        for child in self._get_children():
            if child is not None:
                yield from child.traverse(depth + 1)
    
    def find_all(self, predicate: Union[type, Callable[['ASTNode'], bool]]) -> List['ASTNode']:
        """
        Find all nodes matching a predicate or type.
        
        Args:
            predicate: Either a type to match or a callable predicate function
            
        Returns:
            List of matching nodes
        """
        if callable(predicate) and not isinstance(predicate, type):
            return [node for node in self.traverse() if predicate(node)]
        else:
            return [node for node in self.traverse() if isinstance(node, predicate)]
    
    def find_first(self, predicate: Union[type, Callable[['ASTNode'], bool]]) -> Optional['ASTNode']:
        """
        Find the first node matching a predicate or type.
        
        Args:
            predicate: Either a type to match or a callable predicate function
            
        Returns:
            First matching node or None
        """
        if callable(predicate) and not isinstance(predicate, type):
            for node in self.traverse():
                if predicate(node):
                    return node
        else:
            for node in self.traverse():
                if isinstance(node, predicate):
                    return node
        return None
    
    def _get_children(self) -> List['ASTNode']:
        """Get all child nodes. Override in subclasses."""
        children = []
        for field_name, field_value in self.__dict__.items():
            if isinstance(field_value, ASTNode):
                children.append(field_value)
            elif isinstance(field_value, list):
                children.extend([item for item in field_value if isinstance(item, ASTNode)])
        return children
    
    def pretty(self, indent: int = 0) -> str:
        """
        Pretty print the AST node.
        
        Args:
            indent: Current indentation level
            
        Returns:
            Formatted string representation
        """
        prefix = "  " * indent
        lines = [f"{prefix}{self.__class__.__name__}"]
        
        for field_name, field_value in self.__dict__.items():
            if field_value is None:
                continue
            elif isinstance(field_value, ASTNode):
                lines.append(f"{prefix}  {field_name}:")
                lines.append(field_value.pretty(indent + 2))
            elif isinstance(field_value, list) and field_value:
                if all(isinstance(item, ASTNode) for item in field_value):
                    lines.append(f"{prefix}  {field_name}: [")
                    for item in field_value:
                        lines.append(item.pretty(indent + 2))
                    lines.append(f"{prefix}  ]")
                else:
                    lines.append(f"{prefix}  {field_name}: {field_value}")
            elif not isinstance(field_value, (dict, list)) or field_value:
                lines.append(f"{prefix}  {field_name}: {field_value}")
        
        return "\n".join(lines)
    
    def to_dict(self) -> Dict[str, Any]:
        """Convert back to dictionary representation."""
        result = {"type": self.__class__.__name__}
        
        for field_name, field_value in self.__dict__.items():
            if field_value is None:
                continue
            elif isinstance(field_value, ASTNode):
                result[field_name] = field_value.to_dict()
            elif isinstance(field_value, list):
                result[field_name] = [
                    item.to_dict() if isinstance(item, ASTNode) else item
                    for item in field_value
                ]
            else:
                result[field_name] = field_value
        
        return result
    
    def clone(self) -> 'ASTNode':
        """Create a deep copy of this node."""
        return self.__class__(**self.to_dict())


# ============================================================================
# Query Structure
# ============================================================================

class Query(ASTNode):
    """Root query node."""
    clauses: List['Clause'] = Field(default_factory=list)


class Clause(ASTNode, ABC):
    """Base class for query clauses."""
    pass


# ============================================================================
# Reading Clauses
# ============================================================================

class Match(Clause):
    """MATCH clause."""
    optional: bool = False
    pattern: Optional['Pattern'] = None
    where: Optional['Expression'] = None


class Unwind(Clause):
    """UNWIND clause."""
    expression: Optional['Expression'] = None
    alias: Optional[str] = None


class Call(Clause):
    """CALL clause."""
    procedure_name: Optional[str] = None
    arguments: List['Expression'] = Field(default_factory=list)
    yield_items: List['YieldItem'] = Field(default_factory=list)
    where: Optional['Expression'] = None


class YieldItem(ASTNode):
    """YIELD item in CALL clause."""
    variable: Optional[str] = None
    alias: Optional[str] = None


# ============================================================================
# Projection Clauses
# ============================================================================

class Return(Clause):
    """RETURN clause."""
    distinct: bool = False
    items: List['ReturnItem'] = Field(default_factory=list)
    order_by: Optional[List['OrderByItem']] = None
    skip: Optional[int] = None
    limit: Optional[int] = None


class With(Clause):
    """WITH clause."""
    distinct: bool = False
    items: List['ReturnItem'] = Field(default_factory=list)
    where: Optional['Expression'] = None
    order_by: Optional[List['OrderByItem']] = None
    skip: Optional[int] = None
    limit: Optional[int] = None


class ReturnItem(ASTNode):
    """Item in RETURN or WITH clause."""
    expression: Optional['Expression'] = None
    alias: Optional[str] = None


class OrderByItem(ASTNode):
    """ORDER BY item."""
    expression: Optional['Expression'] = None
    ascending: bool = True


class ReturnAll(ASTNode):
    """RETURN * or WITH *."""
    pass


# ============================================================================
# Writing Clauses
# ============================================================================

class Create(Clause):
    """CREATE clause."""
    pattern: Optional['Pattern'] = None


class Merge(Clause):
    """MERGE clause."""
    pattern: Optional['Pattern'] = None
    on_create: Optional[List['SetItem']] = None
    on_match: Optional[List['SetItem']] = None


class Delete(Clause):
    """DELETE clause."""
    detach: bool = False
    expressions: List['Expression'] = Field(default_factory=list)


class Set(Clause):
    """SET clause."""
    items: List['SetItem'] = Field(default_factory=list)


class SetItem(ASTNode):
    """Item in SET clause."""
    variable: Optional[str] = None
    property: Optional[str] = None
    expression: Optional['Expression'] = None
    labels: List[str] = Field(default_factory=list)


class Remove(Clause):
    """REMOVE clause."""
    items: List['RemoveItem'] = Field(default_factory=list)


class RemoveItem(ASTNode):
    """Item in REMOVE clause."""
    variable: Optional[str] = None
    property: Optional[str] = None
    labels: List[str] = Field(default_factory=list)


# ============================================================================
# Patterns
# ============================================================================

class Pattern(ASTNode):
    """Pattern containing path components."""
    paths: List['PatternPath'] = Field(default_factory=list)


class PatternPath(ASTNode):
    """A single path in a pattern."""
    variable: Optional[str] = None
    elements: List[Union['NodePattern', 'RelationshipPattern']] = Field(default_factory=list)


class NodePattern(ASTNode):
    """Node pattern in MATCH/CREATE."""
    variable: Optional[str] = None
    labels: List[str] = Field(default_factory=list)
    properties: Optional[Dict[str, Any]] = None


class RelationshipPattern(ASTNode):
    """Relationship pattern."""
    variable: Optional[str] = None
    types: List[str] = Field(default_factory=list)
    properties: Optional[Dict[str, Any]] = None
    direction: str = "right"  # "left", "right", "both", "any"
    length: Optional['PathLength'] = None
    where: Optional['Expression'] = None


class PathLength(ASTNode):
    """Variable-length path specification."""
    min: Optional[int] = None
    max: Optional[int] = None
    unbounded: bool = False


# ============================================================================
# Expressions
# ============================================================================

class Expression(ASTNode, ABC):
    """Base class for expressions."""
    pass


class BinaryExpression(Expression, ABC):
    """Base for binary expressions."""
    operator: str
    left: Optional[Expression] = None
    right: Optional[Expression] = None


class Or(BinaryExpression):
    """OR expression."""
    operands: List[Expression] = Field(default_factory=list)
    operator: str = "OR"


class Xor(BinaryExpression):
    """XOR expression."""
    operands: List[Expression] = Field(default_factory=list)
    operator: str = "XOR"


class And(BinaryExpression):
    """AND expression."""
    operands: List[Expression] = Field(default_factory=list)
    operator: str = "AND"


class Not(Expression):
    """NOT expression."""
    operand: Optional[Expression] = None


class Comparison(BinaryExpression):
    """Comparison expression (=, <>, <, >, <=, >=)."""
    pass


class StringPredicate(BinaryExpression):
    """String predicate (STARTS WITH, ENDS WITH, CONTAINS, =~, IN)."""
    pass


class NullCheck(Expression):
    """IS NULL or IS NOT NULL check."""
    operator: str  # "IS NULL" or "IS NOT NULL"
    operand: Optional[Expression] = None


class Arithmetic(BinaryExpression):
    """Arithmetic expression (+, -, *, /, %, ^)."""
    pass


class Unary(Expression):
    """Unary expression (+, -)."""
    operator: str
    operand: Optional[Expression] = None


# ============================================================================
# Property Access and Indexing
# ============================================================================

class PropertyLookup(Expression):
    """Property access (e.g., n.name)."""
    expression: Optional[Expression] = None
    property: Optional[str] = None
    # Legacy fields for backward compatibility
    variable: Optional[str] = None


class IndexLookup(Expression):
    """Array/string indexing (e.g., list[0])."""
    expression: Optional[Expression] = None
    index: Optional[Expression] = None


class Slicing(Expression):
    """Array/string slicing (e.g., list[1..3])."""
    expression: Optional[Expression] = None
    start: Optional[Expression] = None
    end: Optional[Expression] = None


# ============================================================================
# Literals
# ============================================================================

class Literal(Expression, ABC):
    """Base class for literal values."""
    value: Any


class IntegerLiteral(Literal):
    """Integer literal."""
    value: int


class FloatLiteral(Literal):
    """Float literal."""
    value: float


class StringLiteral(Literal):
    """String literal."""
    value: str


class BooleanLiteral(Literal):
    """Boolean literal."""
    value: bool


class NullLiteral(Literal):
    """NULL literal."""
    value: None = None


class ListLiteral(Literal):
    """List literal."""
    value: List[Any] = Field(default_factory=list)
    elements: List[Expression] = Field(default_factory=list)


class MapLiteral(Literal):
    """Map literal."""
    value: Dict[str, Any] = Field(default_factory=dict)
    entries: Dict[str, Expression] = Field(default_factory=dict)


# ============================================================================
# Variables and Parameters
# ============================================================================

class Variable(Expression):
    """Variable reference."""
    name: str


class Parameter(Expression):
    """Query parameter ($param)."""
    name: str


# ============================================================================
# Functions
# ============================================================================

class FunctionInvocation(Expression):
    """Function call."""
    name: Union[str, Dict[str, str]]  # Simple name or {namespace, name}
    arguments: Optional[Dict[str, Any]] = None
    distinct: bool = False


class CountStar(Expression):
    """COUNT(*) function."""
    pass


# ============================================================================
# Advanced Expressions
# ============================================================================

class Exists(Expression):
    """EXISTS subquery expression."""
    content: Optional[Union['Pattern', 'Query']] = None


class ListComprehension(Expression):
    """List comprehension [x IN list WHERE pred | expr]."""
    variable: Optional[str] = None
    list_expr: Optional[Expression] = None
    where: Optional[Expression] = None
    map_expr: Optional[Expression] = None


class PatternComprehension(Expression):
    """Pattern comprehension [path = pattern | expr]."""
    variable: Optional[str] = None
    pattern: Optional[Pattern] = None
    where: Optional[Expression] = None
    map_expr: Optional[Expression] = None


class MapProjection(Expression):
    """Map projection (e.g., node{.prop, computed: expr})."""
    variable: Optional[str] = None
    elements: List['MapElement'] = Field(default_factory=list)
    include_all: bool = False


class MapElement(ASTNode):
    """Element in map projection."""
    property: Optional[str] = None
    expression: Optional[Expression] = None
    all_properties: bool = False


class CaseExpression(Expression):
    """CASE expression (simple or searched)."""
    expression: Optional[Expression] = None  # For simple CASE
    when_clauses: List['WhenClause'] = Field(default_factory=list)
    else_expr: Optional[Expression] = None


class WhenClause(ASTNode):
    """WHEN clause in CASE expression."""
    condition: Optional[Expression] = None
    result: Optional[Expression] = None


class Reduce(Expression):
    """REDUCE expression."""
    accumulator: Optional[str] = None
    initial: Optional[Expression] = None
    variable: Optional[str] = None
    list_expr: Optional[Expression] = None
    map_expr: Optional[Expression] = None


class Quantifier(Expression):
    """Quantifier expression (ALL, ANY, NONE, SINGLE)."""
    quantifier: str  # "ALL", "ANY", "NONE", "SINGLE"
    variable: Optional[str] = None
    list_expr: Optional[Expression] = None
    where: Optional[Expression] = None


# ============================================================================
# Special Functions
# ============================================================================

class ShortestPath(Expression):
    """SHORTESTPATH function."""
    pattern: Optional[Pattern] = None


class AllShortestPaths(Expression):
    """ALLSHORTESTPATHS function."""
    pattern: Optional[Pattern] = None


# ============================================================================
# AST Converter
# ============================================================================

class ASTConverter:
    """Converts dictionary-based AST to Pydantic models."""
    
    def convert(self, node: Any) -> Optional[ASTNode]:
        """
        Convert a dictionary-based AST node to a Pydantic model.
        
        Args:
            node: Dictionary, list, or primitive value from grammar parser
            
        Returns:
            Typed ASTNode or None
        """
        if node is None:
            return None
        
        # Handle Lark Tree objects (convert to string representation for now)
        if hasattr(node, '__class__') and 'Tree' in node.__class__.__name__:
            # This is a Lark Tree, try to extract data
            if hasattr(node, 'children') and node.children:
                # Get the first child which should be the actual data
                return self.convert(node.children[0] if node.children else None)
            return None
        
        if not isinstance(node, dict):
            # Primitive value  
            result = self._convert_primitive(node)
            # Wrap primitives in appropriate AST nodes when in expression context
            match result:
                case str() if result:  # Non-empty string
                    return Variable(name=result)
                case bool():
                    return BooleanLiteral(value=result)
                case int():
                    return IntegerLiteral(value=result)
                case float():
                    return FloatLiteral(value=result)
                case _:
                    return result
        
        node_type = node.get('type')
        if not node_type:
            return None
        
        # Map type names to classes
        converter_method = getattr(self, f'_convert_{node_type}', None)
        if converter_method:
            return converter_method(node)
        
        # Generic fallback
        return self._convert_generic(node, node_type)
    
    def _convert_primitive(self, value: Any) -> Any:
        """Convert primitive values, returning them as-is for simple types.
        
        For primitive types (bool, int, float, str, None), returns the value directly.
        For complex types (list, dict), converts to AST nodes.
        """
        # Return primitives as-is using match-case pattern matching
        match value:
            case None:
                return None
            case bool():
                return value
            case int():
                return value
            case float():
                return value
            case str():
                return value
            case list():
                # Return empty list as-is, otherwise convert elements
                if not value:
                    return []
                elements = [self.convert(item) for item in value]
                return ListLiteral(value=value, elements=cast(List[Expression], [e for e in elements if e]))
            case dict():
                # Return empty dict as-is
                if not value:
                    return {}
                # If it has 'type' field, it's an AST dict, not a primitive
                if 'type' in value:
                    return None
                # Plain dictionary - convert to MapLiteral
                entries = {k: self.convert(v) for k, v in value.items()}
                return MapLiteral(value=value, entries=cast(Dict[str, Expression], {k: v for k, v in entries.items() if v}))
            case _:
                return None
    
    def _convert_Query(self, node: dict) -> Query:
        """Convert Query node."""
        # Handle both 'clauses' and 'statements' structure
        clauses = []
        
        if 'clauses' in node:
            clauses = [self.convert(c) for c in node.get('clauses', [])]
        elif 'statements' in node:
            # New structure with statements
            for stmt_list in node.get('statements', []):
                if isinstance(stmt_list, list):
                    for stmt in stmt_list:
                        converted = self.convert(stmt)
                        if converted:
                            # If it's a QueryStatement, extract its clauses
                            if hasattr(converted, 'clauses'):
                                clauses.extend(converted.clauses if isinstance(converted.clauses, list) else [])
                            elif isinstance(converted, Clause):
                                clauses.append(converted)
        
        return Query(clauses=[c for c in clauses if isinstance(c, Clause)])
    
    def _convert_QueryStatement(self, node: dict) -> Query:
        """Convert QueryStatement node to Query with clauses."""
        clauses = []
        
        # Extract reading clauses (MATCH, etc.)
        for clause_item in node.get('clauses', []):
            converted = self.convert(clause_item)
            if converted and isinstance(converted, Clause):
                clauses.append(converted)
        
        # Extract return statement
        if 'return' in node and node['return']:
            ret_clause = self.convert(node['return'])
            if ret_clause and isinstance(ret_clause, Clause):
                clauses.append(ret_clause)
        
        return Query(clauses=clauses)
    
    def _convert_UpdateStatement(self, node: dict) -> Query:
        """Convert UpdateStatement which contains CREATE/SET/DELETE/etc."""
        clauses = []
        
        # Add prefix clauses (usually MATCH before UPDATE)
        prefix = node.get('prefix', [])
        if prefix:
            for clause in prefix:
                converted = self.convert(clause)
                if converted and isinstance(converted, Clause):
                    clauses.append(converted)
        
        # Add update clauses
        updates = node.get('updates', [])
        if updates:
            for clause in updates:
                converted = self.convert(clause)
                if converted and isinstance(converted, Clause):
                    clauses.append(converted)
        
        # Handle return statement separately
        if node.get('return'):
            ret_clause = self.convert(node['return'])
            if ret_clause and isinstance(ret_clause, Clause):
                clauses.append(ret_clause)
        
        return Query(clauses=clauses)
    
    def _convert_CreateClause(self, node: dict) -> Create:
        """Convert CreateClause node."""
        return Create(pattern=cast(Optional[Pattern], self.convert(node.get('pattern'))))
    
    def _convert_SetClause(self, node: dict) -> Set:
        """Convert SetClause node."""
        items = [self.convert(item) for item in node.get('items', [])]
        return Set(items=cast(List[SetItem], [i for i in items if i]))
    
    def _convert_DeleteClause(self, node: dict) -> Delete:
        """Convert DeleteClause node."""
        items = node.get('items', [])
        exprs = [self.convert(e) for e in items]
        return Delete(
            detach=node.get('detach', False),
            expressions=cast(List[Expression], [e for e in exprs if e])
        )
    
    def _convert_RemoveClause(self, node: dict) -> Remove:
        """Convert RemoveClause node."""
        items = [self.convert(item) for item in node.get('items', [])]
        return Remove(items=cast(List[RemoveItem], [i for i in items if i]))
    
    def _convert_MergeClause(self, node: dict) -> Merge:
        """Convert MergeClause node."""
        # Convert actions to on_create and on_match
        on_create = []
        on_match = []
        for action in node.get('actions', []):
            if isinstance(action, dict):
                if action.get('on') == 'create':
                    set_clause = action.get('set')
                    if set_clause:
                        converted = self.convert(set_clause)
                        if converted:
                            on_create.append(converted)
                elif action.get('on') == 'match':
                    set_clause = action.get('set')
                    if set_clause:
                        converted = self.convert(set_clause)
                        if converted:
                            on_match.append(converted)
        
        return Merge(
            pattern=cast(Optional[Pattern], self.convert(node.get('pattern'))),
            on_create=cast(Optional[List[SetItem]], on_create) if on_create else None,
            on_match=cast(Optional[List[SetItem]], on_match) if on_match else None
        )
    
    def _convert_MatchClause(self, node: dict) -> Match:
        """Convert MatchClause node."""
        where_cond = None
        if 'where' in node and node['where']:
            where_dict = node['where']
            if isinstance(where_dict, dict) and 'condition' in where_dict:
                where_cond = self.convert(where_dict['condition'])
            else:
                where_cond = self.convert(where_dict)
        
        return Match(
            optional=node.get('optional', False),
            pattern=cast(Optional[Pattern], self.convert(node.get('pattern'))),
            where=cast(Optional[Expression], where_cond)
        )
    
    def _convert_ReturnStatement(self, node: dict) -> Return:
        """Convert ReturnStatement node."""
        items = []
        
        # Handle body which contains return items
        body = node.get('body')
        if body:
            if isinstance(body, dict) and body.get('type') == 'ReturnBody':
                items_list = body.get('items', [])
                items = [self.convert(item) for item in items_list]
        
        order_by = None
        if node.get('order'):
            order_items = node['order'].get('items', []) if isinstance(node['order'], dict) else []
            converted_order = [self.convert(item) for item in order_items if item is not None]
            order_by = [o for o in converted_order if o is not None]  # Filter out None values
        
        # Extract limit value
        limit_val = None
        if node.get('limit'):
            limit_clause = node['limit']
            if isinstance(limit_clause, dict):
                limit_val = limit_clause.get('value')
                # Handle Lark Tree objects
                if hasattr(limit_val, '__class__') and limit_val.__class__.__name__ == 'Tree':
                    # Get first child which should be the integer
                    if limit_val.children:
                        limit_val = limit_val.children[0]
                if isinstance(limit_val, int):
                    pass  # Already an int
                elif hasattr(limit_val, 'value'):
                    limit_val = int(limit_val.value)
                else:
                    try:
                        limit_val = int(str(limit_val))
                    except (ValueError, TypeError):
                        limit_val = None
        
        # Extract skip value
        skip_val = None
        if node.get('skip'):
            skip_clause = node['skip']
            if isinstance(skip_clause, dict):
                skip_val = skip_clause.get('value')
                if isinstance(skip_val, int):
                    pass
                elif hasattr(skip_val, 'value'):
                    skip_val = int(skip_val.value)
                else:
                    try:
                        skip_val = int(str(skip_val))
                    except (ValueError, TypeError):
                        skip_val = None
        
        return Return(
            distinct=node.get('distinct', False),
            items=cast(List[ReturnItem], [i for i in items if i]),
            order_by=cast(Optional[List[OrderByItem]], order_by) if order_by else None,
            skip=skip_val,
            limit=limit_val
        )
    
    def _convert_Match(self, node: dict) -> Match:
        """Convert Match node."""
        return Match(
            optional=node.get('optional', False),
            pattern=cast(Optional[Pattern], self.convert(node.get('pattern'))),
            where=cast(Optional[Expression], self.convert(node.get('where')))
        )
    
    def _convert_Return(self, node: dict) -> Return:
        """Convert Return node."""
        items = [self.convert(item) for item in node.get('items', [])]
        order_by = None
        if node.get('order_by'):
            order_by = [self.convert(item) for item in node['order_by']]
        
        return Return(
            distinct=node.get('distinct', False),
            items=cast(List[ReturnItem], [i for i in items if i]),
            order_by=cast(Optional[List[OrderByItem]], order_by),
            skip=node.get('skip'),
            limit=node.get('limit')
        )
    
    def _convert_ReturnItem(self, node: dict) -> ReturnItem:
        """Convert ReturnItem node."""
        return ReturnItem(
            expression=cast(Optional[Expression], self.convert(node.get('expression'))),
            alias=node.get('alias')
        )
    
    def _convert_ReturnAll(self, node: dict) -> ReturnAll:
        """Convert ReturnAll node."""
        return ReturnAll()
    
    def _convert_With(self, node: dict) -> With:
        """Convert With node."""
        items = [self.convert(item) for item in node.get('items', [])]
        order_by = None
        if node.get('order_by'):
            order_by = [self.convert(item) for item in node['order_by']]
        
        return With(
            distinct=node.get('distinct', False),
            items=cast(List[ReturnItem], [i for i in items if i]),
            where=cast(Optional[Expression], self.convert(node.get('where'))),
            order_by=cast(Optional[List[OrderByItem]], order_by),
            skip=node.get('skip'),
            limit=node.get('limit')
        )
    
    def _convert_Create(self, node: dict) -> Create:
        """Convert Create node."""
        return Create(pattern=cast(Optional[Pattern], self.convert(node.get('pattern'))))
    
    def _convert_Merge(self, node: dict) -> Merge:
        """Convert Merge node."""
        on_create = None
        if node.get('on_create'):
            on_create = [self.convert(item) for item in node['on_create']]
        
        on_match = None
        if node.get('on_match'):
            on_match = [self.convert(item) for item in node['on_match']]
        
        return Merge(
            pattern=cast(Optional[Pattern], self.convert(node.get('pattern'))),
            on_create=cast(Optional[List[SetItem]], on_create),
            on_match=cast(Optional[List[SetItem]], on_match)
        )
    
    def _convert_Delete(self, node: dict) -> Delete:
        """Convert Delete node."""
        exprs = [self.convert(e) for e in node.get('expressions', [])]
        return Delete(
            detach=node.get('detach', False),
            expressions=cast(List[Expression], [e for e in exprs if e])
        )
    
    def _convert_Set(self, node: dict) -> Set:
        """Convert Set node."""
        items = [self.convert(item) for item in node.get('items', [])]
        return Set(items=cast(List[SetItem], [i for i in items if i]))
    
    def _convert_SetItem(self, node: dict) -> SetItem:
        """Convert SetItem node."""
        return SetItem(
            variable=node.get('variable'),
            property=node.get('property'),
            expression=cast(Optional[Expression], self.convert(node.get('expression'))),
            labels=node.get('labels', [])
        )
    
    def _convert_SetProperty(self, node: dict) -> SetItem:
        """Convert SetProperty node to SetItem."""
        # Extract property name from PropertyLookup dict if needed
        prop = node.get('property')
        if isinstance(prop, dict) and prop.get('type') == 'PropertyLookup':
            prop = prop.get('property')
        return SetItem(
            variable=node.get('variable'),
            property=prop,
            expression=cast(Optional[Expression], self.convert(node.get('value'))),
            labels=[]
        )
    
    def _convert_SetLabels(self, node: dict) -> SetItem:
        """Convert SetLabels node to SetItem."""
        labels = node.get('labels', [])
        # Convert label expression if needed
        if isinstance(labels, dict):
            labels = [labels.get('name', '')]
        elif not isinstance(labels, list):
            labels = [str(labels)]
        return SetItem(
            variable=node.get('variable'),
            property=None,
            expression=None,
            labels=labels
        )
    
    def _convert_SetAllProperties(self, node: dict) -> SetItem:
        """Convert SetAllProperties node to SetItem."""
        return SetItem(
            variable=node.get('variable'),
            property='*',  # Indicates all properties
            expression=cast(Optional[Expression], self.convert(node.get('value'))),
            labels=[]
        )
    
    def _convert_Remove(self, node: dict) -> Remove:
        """Convert Remove node."""
        items = [self.convert(item) for item in node.get('items', [])]
        return Remove(items=cast(List[RemoveItem], [i for i in items if i]))
    
    def _convert_RemoveItem(self, node: dict) -> RemoveItem:
        """Convert RemoveItem node."""
        return RemoveItem(
            variable=node.get('variable'),
            property=node.get('property'),
            labels=node.get('labels', [])
        )
    
    def _convert_RemoveProperty(self, node: dict) -> RemoveItem:
        """Convert RemoveProperty node to RemoveItem."""
        # Extract property name from PropertyLookup dict if needed
        prop = node.get('property')
        if isinstance(prop, dict) and prop.get('type') == 'PropertyLookup':
            prop = prop.get('property')
        return RemoveItem(
            variable=node.get('variable'),
            property=prop,
            labels=[]
        )
    
    def _convert_RemoveLabels(self, node: dict) -> RemoveItem:
        """Convert RemoveLabels node to RemoveItem."""
        labels = node.get('labels', [])
        # Convert label expression if needed
        if isinstance(labels, dict):
            labels = [labels.get('name', '')]
        elif not isinstance(labels, list):
            labels = [str(labels)]
        return RemoveItem(
            variable=node.get('variable'),
            property=None,
            labels=labels
        )
    
    def _convert_Unwind(self, node: dict) -> Unwind:
        """Convert Unwind node."""
        return Unwind(
            expression=cast(Optional[Expression], self.convert(node.get('expression'))),
            alias=node.get('alias')
        )
    
    def _convert_Call(self, node: dict) -> Call:
        """Convert Call node."""
        args = [self.convert(a) for a in node.get('arguments', [])]
        yield_items = [self.convert(y) for y in node.get('yield_items', [])]
        
        return Call(
            procedure_name=node.get('procedure_name'),
            arguments=cast(List[Expression], [a for a in args if a]),
            yield_items=cast(List[YieldItem], [y for y in yield_items if y]),
            where=cast(Optional[Expression], self.convert(node.get('where')))
        )
    
    def _convert_Pattern(self, node: dict) -> Pattern:
        """Convert Pattern node."""
        paths = [self.convert(p) for p in node.get('paths', [])]
        # Filter out Nones and convert PatternElements to PatternPaths
        converted_paths = []
        for p in paths:
            if p is None:
                continue
            # PathPattern might come as PathPattern or need conversion from PatternElement
            if isinstance(p, PatternPath):
                converted_paths.append(p)
            elif isinstance(p, dict):
                # Try to convert as PathPattern
                pp = self._convert_PathPattern(p) if p.get('type') == 'PathPattern' else None
                if pp:
                    converted_paths.append(pp)
        
        return Pattern(paths=converted_paths)
    
    def _convert_PathPattern(self, node: dict) -> PatternPath:
        """Convert PathPattern node."""
        # Extract elements from the pattern element
        elements = []
        
        element = node.get('element')
        if element:
            if isinstance(element, dict) and element.get('type') == 'PatternElement':
                # Extract parts from PatternElement
                parts = element.get('parts', [])
                for part in parts:
                    converted = self.convert(part)
                    if converted:
                        elements.append(converted)
            else:
                converted = self.convert(element)
                if converted:
                    elements.append(converted)
        
        return PatternPath(
            variable=node.get('variable'),
            elements=elements
        )
    
    def _convert_PatternElement(self, node: dict) -> PatternPath:
        """Convert PatternElement to PatternPath."""
        elements = []
        for part in node.get('parts', []):
            converted = self.convert(part)
            if converted:
                elements.append(converted)
        
        return PatternPath(variable=None, elements=elements)
    
    def _convert_PatternPath(self, node: dict) -> PatternPath:
        """Convert PatternPath node."""
        elements = [self.convert(e) for e in node.get('elements', [])]
        return PatternPath(
            variable=node.get('variable'),
            elements=cast(List[Union[NodePattern, RelationshipPattern]], [e for e in elements if e])
        )
    
    def _convert_NodePattern(self, node: dict) -> NodePattern:
        """Convert NodePattern node."""
        return NodePattern(
            variable=node.get('variable'),
            labels=node.get('labels', []),
            properties=node.get('properties')
        )
    
    def _convert_RelationshipPattern(self, node: dict) -> RelationshipPattern:
        """Convert RelationshipPattern node."""
        return RelationshipPattern(
            variable=node.get('variable'),
            types=node.get('types', []),
            properties=node.get('properties'),
            direction=node.get('direction', 'right'),
            length=cast(Optional[PathLength], self.convert(node.get('length'))),
            where=cast(Optional[Expression], self.convert(node.get('where')))
        )
    
    def _convert_PathLength(self, node: dict) -> PathLength:
        """Convert PathLength node."""
        return PathLength(
            min=node.get('min'),
            max=node.get('max'),
            unbounded=node.get('unbounded', False)
        )
    
    def _convert_Or(self, node: dict) -> Or:
        """Convert Or node."""
        operands = [self.convert(op) for op in node.get('operands', [])]
        return Or(operands=cast(List[Expression], [o for o in operands if o]), operator="OR")
    
    def _convert_Xor(self, node: dict) -> Xor:
        """Convert Xor node."""
        operands = [self.convert(op) for op in node.get('operands', [])]
        return Xor(operands=cast(List[Expression], [o for o in operands if o]), operator="XOR")
    
    def _convert_And(self, node: dict) -> And:
        """Convert And node."""
        operands = [self.convert(op) for op in node.get('operands', [])]
        return And(operands=cast(List[Expression], [o for o in operands if o]), operator="AND")
    
    def _convert_Not(self, node: dict) -> Not:
        """Convert Not node."""
        return Not(operand=cast(Optional[Expression], self.convert(node.get('operand'))))
    
    def _convert_Comparison(self, node: dict) -> Comparison:
        """Convert Comparison node."""
        return Comparison(
            operator=node.get('operator', '='),
            left=cast(Optional[Expression], self.convert(node.get('left'))),
            right=cast(Optional[Expression], self.convert(node.get('right')))
        )
    
    def _convert_StringPredicate(self, node: dict) -> StringPredicate:
        """Convert StringPredicate node."""
        return StringPredicate(
            operator=node.get('operator', 'CONTAINS'),
            left=cast(Optional[Expression], self.convert(node.get('left'))),
            right=cast(Optional[Expression], self.convert(node.get('right')))
        )
    
    def _convert_NullCheck(self, node: dict) -> NullCheck:
        """Convert NullCheck node."""
        return NullCheck(
            operator=node.get('operator', 'IS NULL'),
            operand=cast(Optional[Expression], self.convert(node.get('operand')))
        )
    
    def _convert_Arithmetic(self, node: dict) -> Arithmetic:
        """Convert Arithmetic node."""
        return Arithmetic(
            operator=node.get('operator', '+'),
            left=cast(Optional[Expression], self.convert(node.get('left'))),
            right=cast(Optional[Expression], self.convert(node.get('right')))
        )
    
    def _convert_Unary(self, node: dict) -> Unary:
        """Convert Unary node."""
        return Unary(
            operator=node.get('operator', '+'),
            operand=cast(Optional[Expression], self.convert(node.get('operand')))
        )
    
    def _convert_PropertyLookup(self, node: dict) -> PropertyLookup:
        """Convert PropertyLookup node."""
        return PropertyLookup(
            expression=cast(Optional[Expression], self.convert(node.get('expression'))),
            property=node.get('property'),
            variable=node.get('variable')  # Legacy support
        )
    
    def _convert_PropertyAccess(self, node: dict) -> PropertyLookup:
        """Convert PropertyAccess node (alternative name for PropertyLookup)."""
        return PropertyLookup(
            expression=cast(Optional[Expression], self.convert(node.get('object'))),
            property=node.get('property')
        )
    
    def _convert_IndexLookup(self, node: dict) -> IndexLookup:
        """Convert IndexLookup node."""
        return IndexLookup(
            expression=cast(Optional[Expression], self.convert(node.get('expression'))),
            index=cast(Optional[Expression], self.convert(node.get('index')))
        )
    
    def _convert_Slicing(self, node: dict) -> Slicing:
        """Convert Slicing node."""
        return Slicing(
            expression=cast(Optional[Expression], self.convert(node.get('expression'))),
            start=cast(Optional[Expression], self.convert(node.get('start'))),
            end=cast(Optional[Expression], self.convert(node.get('end')))
        )
    
    def _convert_FunctionInvocation(self, node: dict) -> FunctionInvocation:
        """Convert FunctionInvocation node."""
        return FunctionInvocation(
            name=node.get('name', 'unknown'),
            arguments=node.get('arguments'),
            distinct=node.get('arguments', {}).get('distinct', False) if isinstance(node.get('arguments'), dict) else False
        )
    
    def _convert_CountStar(self, node: dict) -> CountStar:
        """Convert CountStar node."""
        return CountStar()
    
    def _convert_Exists(self, node: dict) -> Exists:
        """Convert Exists node."""
        return Exists(content=cast(Optional[Union[Pattern, Query]], self.convert(node.get('content'))))
    
    def _convert_ListComprehension(self, node: dict) -> ListComprehension:
        """Convert ListComprehension node."""
        return ListComprehension(
            variable=node.get('variable'),
            list_expr=cast(Optional[Expression], self.convert(node.get('in'))),  # 'in' from grammar
            where=cast(Optional[Expression], self.convert(node.get('where'))),
            map_expr=cast(Optional[Expression], self.convert(node.get('projection')))  # 'projection' from grammar
        )
    
    def _convert_PatternComprehension(self, node: dict) -> PatternComprehension:
        """Convert PatternComprehension node."""
        return PatternComprehension(
            variable=node.get('variable'),
            pattern=cast(Optional[Pattern], self.convert(node.get('pattern'))),
            where=cast(Optional[Expression], self.convert(node.get('where'))),
            map_expr=cast(Optional[Expression], self.convert(node.get('map')))
        )
    
    def _convert_Quantifier(self, node: dict) -> Quantifier:
        """Convert Quantifier node."""
        return Quantifier(
            quantifier=node.get('quantifier', 'ALL'),
            variable=node.get('variable'),
            list_expr=cast(Optional[Expression], self.convert(node.get('in'))),
            where=cast(Optional[Expression], self.convert(node.get('where')))
        )
    
    def _convert_MapProjection(self, node: dict) -> MapProjection:
        """Convert MapProjection node."""
        elements = [self.convert(e) for e in node.get('elements', [])]
        return MapProjection(
            variable=node.get('variable'),
            elements=cast(List[MapElement], [e for e in elements if e]),
            include_all=node.get('include_all', False)
        )
    
    def _convert_MapElement(self, node: dict) -> MapElement:
        """Convert MapElement node."""
        return MapElement(
            property=node.get('property'),
            expression=cast(Optional[Expression], self.convert(node.get('expression'))),
            all_properties=node.get('all_properties', False)
        )
    
    def _convert_CaseExpression(self, node: dict) -> CaseExpression:
        """Convert CaseExpression node."""
        when_clauses = [self.convert(w) for w in node.get('when_clauses', [])]
        return CaseExpression(
            expression=cast(Optional[Expression], self.convert(node.get('expression'))),
            when_clauses=cast(List[WhenClause], [w for w in when_clauses if w]),
            else_expr=cast(Optional[Expression], self.convert(node.get('else')))
        )
    
    def _convert_SearchedCase(self, node: dict) -> CaseExpression:
        """Convert SearchedCase to CaseExpression."""
        when_clauses = [self.convert(w) for w in node.get('when', [])]
        else_node = node.get('else')
        else_expr = None
        if else_node:
            if isinstance(else_node, dict) and else_node.get('type') == 'Else':
                else_expr = self.convert(else_node.get('value'))
            else:
                else_expr = self.convert(else_node)
        return CaseExpression(
            expression=None,  # Searched case has no test expression
            when_clauses=cast(List[WhenClause], [w for w in when_clauses if w]),
            else_expr=cast(Optional[Expression], else_expr)
        )
    
    def _convert_SimpleCase(self, node: dict) -> CaseExpression:
        """Convert SimpleCase to CaseExpression."""
        when_clauses = [self.convert(w) for w in node.get('when', [])]
        else_node = node.get('else')
        else_expr = None
        if else_node:
            if isinstance(else_node, dict) and else_node.get('type') == 'Else':
                else_expr = self.convert(else_node.get('value'))
            else:
                else_expr = self.convert(else_node)
        return CaseExpression(
            expression=cast(Optional[Expression], self.convert(node.get('operand'))),
            when_clauses=cast(List[WhenClause], [w for w in when_clauses if w]),
            else_expr=cast(Optional[Expression], else_expr)
        )
    
    def _convert_Else(self, node: dict):
        """Convert Else node - just extract the value."""
        return self.convert(node.get('value'))
    
    def _convert_SimpleWhen(self, node: dict) -> WhenClause:
        """Convert SimpleWhen to WhenClause."""
        return WhenClause(
            condition=cast(Optional[Expression], self.convert(node.get('value'))),
            result=cast(Optional[Expression], self.convert(node.get('result')))
        )
    
    def _convert_SearchedWhen(self, node: dict) -> WhenClause:
        """Convert SearchedWhen to WhenClause."""
        return WhenClause(
            condition=cast(Optional[Expression], self.convert(node.get('condition'))),
            result=cast(Optional[Expression], self.convert(node.get('result')))
        )
    
    def _convert_Reduce(self, node: dict) -> Reduce:
        """Convert Reduce node."""
        return Reduce(
            accumulator=node.get('accumulator'),
            initial=cast(Optional[Expression], self.convert(node.get('initial'))),
            variable=node.get('variable'),
            list_expr=cast(Optional[Expression], self.convert(node.get('list'))),
            map_expr=cast(Optional[Expression], self.convert(node.get('map')))
        )
    
    def _convert_All(self, node: dict) -> Quantifier:
        """Convert All quantifier."""
        return Quantifier(
            quantifier="ALL",
            variable=node.get('variable'),
            list_expr=cast(Optional[Expression], self.convert(node.get('list'))),
            where=cast(Optional[Expression], self.convert(node.get('where')))
        )
    
    def _convert_Any(self, node: dict) -> Quantifier:
        """Convert Any quantifier."""
        return Quantifier(
            quantifier="ANY",
            variable=node.get('variable'),
            list_expr=cast(Optional[Expression], self.convert(node.get('list'))),
            where=cast(Optional[Expression], self.convert(node.get('where')))
        )
    
    def _convert_None(self, node: dict) -> Quantifier:
        """Convert None quantifier."""
        return Quantifier(
            quantifier="NONE",
            variable=node.get('variable'),
            list_expr=cast(Optional[Expression], self.convert(node.get('list'))),
            where=cast(Optional[Expression], self.convert(node.get('where')))
        )
    
    def _convert_Single(self, node: dict) -> Quantifier:
        """Convert Single quantifier."""
        return Quantifier(
            quantifier="SINGLE",
            variable=node.get('variable'),
            list_expr=cast(Optional[Expression], self.convert(node.get('list'))),
            where=cast(Optional[Expression], self.convert(node.get('where')))
        )
    
    def _convert_OrderByItem(self, node: dict) -> OrderByItem:
        """Convert OrderByItem node."""
        return OrderByItem(
            expression=cast(Optional[Expression], self.convert(node.get('expression'))),
            ascending=node.get('ascending', True)
        )
    
    def _convert_WhereClause(self, node: dict) -> Optional[Expression]:
        """Convert WhereClause - just return the condition."""
        return cast(Optional[Expression], self.convert(node.get('condition')))
    
    def _convert_ReturnBody(self, node: dict) -> Optional[ASTNode]:
        """Convert ReturnBody - extract items."""
        # This is typically handled by ReturnStatement converter
        return None
    
    def _convert_generic(self, node: dict, node_type: str) -> Optional[ASTNode]:
        """Generic converter for unknown node types."""
        # Try to find a matching class
        node_class = globals().get(node_type)
        if node_class and issubclass(node_class, ASTNode):
            # Convert all fields
            converted_fields = {}
            for key, value in node.items():
                if key == 'type':
                    continue
                if isinstance(value, dict):
                    converted_fields[key] = self.convert(value)
                elif isinstance(value, list):
                    converted_fields[key] = [self.convert(v) for v in value]
                else:
                    converted_fields[key] = value
            
            try:
                return node_class(**converted_fields)
            except Exception:
                pass
        
        return None


# ============================================================================
# Utility Functions
# ============================================================================

def convert_ast(raw_ast: Any) -> Optional[ASTNode]:
    """
    Convert a dictionary-based AST to typed Pydantic models.
    
    Args:
        raw_ast: Dictionary or other value from grammar parser
        
    Returns:
        Typed ASTNode or None
        
    Example:
        >>> from pycypher.grammar_parser import GrammarParser
        >>> parser = GrammarParser()
        >>> raw_ast = parser.parse_to_ast("MATCH (n) RETURN n")
        >>> typed_ast = convert_ast(raw_ast)
        >>> print(typed_ast.pretty())
    """
    converter = ASTConverter()
    return converter.convert(raw_ast)


def traverse_ast(node: ASTNode) -> Iterator[ASTNode]:
    """
    Traverse an AST depth-first.
    
    Args:
        node: Root AST node
        
    Yields:
        Each node in the tree
        
    Example:
        >>> for ast_node in traverse_ast(typed_ast):
        ...     print(ast_node.__class__.__name__)
    """
    return node.traverse()


def find_nodes(node: ASTNode, node_type: type) -> List[ASTNode]:
    """
    Find all nodes of a specific type.
    
    Args:
        node: Root AST node
        node_type: Type to search for
        
    Returns:
        List of matching nodes
        
    Example:
        >>> matches = find_nodes(typed_ast, Match)
        >>> print(f"Found {len(matches)} MATCH clauses")
    """
    return node.find_all(node_type)


def print_ast(node: ASTNode, indent: int = 0) -> None:
    """
    Pretty print an AST.
    
    Args:
        node: AST node to print
        indent: Initial indentation level
        
    Example:
        >>> print_ast(typed_ast)
    """
    print(node.pretty(indent))
